# C++ 类与对象

## 概念

```cpp
class name {
public:
protected:
private:
};
```

> [!NOTE]
>
> - class 表明定义是一个类
> - public等为**存取控制属性（访问权限）**，用来控制对象成员的存取。默认访问权限为private。
> - 类的成员有**数据成员**和**函数成员**两类。类的数据成员一般用来描述该类对象的静态属性，称为**属性**；函数成员用来描述类行为或动态属性，称为**方法**。

## 构造函数与析构函数

**构造函数（constructor）**是与类名相同的再建立对象是自动调用的函数。作为类的成员函数，构造函数可以直接访问类的所有数据成员，可以是内敛函数，可以不带任何参数，可以带有参数表以默认形参值。

构造函数是一种特殊的函数，主要用来再创建对象时初始化对象，即为对象的数据成员赋予初始值。

> [!NOTE]
>
> 1. 构造函数的函数名必须与定义它的类同名
> 2. 构造函数没有返回值，如果再构造函数前加void是错误的。
> 3. 构造函数被声明定义为**公有函数**
> 4. 构造函数再在建立对象时有系统自动调用

**析构函数（destructor）**也叫拆构函数，实在对象小时之前的瞬间自动调用的函数，其形式如下

```cpp
~Function();
```

> [!NOTE]
>
> 1. 析构函数没有任何参数，不能被重载，但是可以是虚函数，一个类只有一个析构函数。
> 2. 析构函数没有返回值
> 3. 析构函数名在类名钱加上一个逻辑非运算符“~”，以与构造函数相区别
> 4. 析构函数一般由用户自己定义，在对象小时时由系统自动调用，如果用户没有定义析构函数，系统将自动生成一个不做任何事的默认析构函数。

```cpp
#include <iostream>

class Clock {
    private:
    int H, M, S;
    public:
    Clock(int h = 0, int m = 0, int s = 0) {
        H = h, M = m, S = s;
        std::cout << "constructor: " << H << ':' << M << ':' << S << std::endl;
    }
    ~Clock() {
        std::cout << "destructor: " << H << ':' << M << ':' << S << std::endl;
    }
};

Clock C1(9, 30, 0);

int main() {
    Clock C2(10, 0, 0);
    return 0;
}	
```

这段代码的输出为：

```
constructor: 9:30:0
constructor: 10:0:0
destructor: 10:0:0
destructor: 9:30:0
```

> [!NOTE]
>
> 从运行结果来看，构造函数执行的顺序为C1::Clock() -> C2::Clock()，析构函数调用的顺序为C2::Clock() -> C1::Clock()，因为对象在栈中建立，因此小时的顺序与建立的顺序相反。

## 对象的使用

### 对象指针

对象和一般变量一样，占用一块连续的内存区域，因此可以使用一个指向对象的指针来访问对象，即**对象指针**，他只想存放该对象的地址。建立对象指针并没有建立对象，所以此时不调用构造函数。如同通过对象名访问对象成员一样，使用对象指针也之恶能访问该类的共有数据成员，但与使用`.`运算符不同，对象指针采用`->`运算符访问共有数据成员和成员函数。例如：

```cpp
Clock C1(8, 0, 0);
Clock *Cptr;
Cptr = &C1;
Cp -> DisplayTime();
```

### 对象引用

```cpp
Clock C1(8, 20, 20);
Clock &Cr = C1;
Cr.DisplayTime();
```

### 对象数组

**对象数组**是以对象为元素的数组，对象数组的定义，赋值引用与普通数组一样，只是数组元素与普通数组的数组元素不同。

### 动态对象

**动态对象**时指编程者随时动态建立并可随时消失的对象。建立动态对象采用的动态申请内存的语句new，删除动态对象使用delete语句。建立一个动态对象的格式如下：

> [!NOTE]
>
> - 对象指针的类型应该与类名一致
> - 动态对象储存在new语句从堆中申请的空间
> - 建立动态对象时要调用构造函数

```cpp
Clock * Cp;
Cp = new Clock;
Cp -> DisplayTime();
cp = new Clock(8, 0, 0);
cp -> DisplayTime();
delete Cp;
```

## 静态成员
